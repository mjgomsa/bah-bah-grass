"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PinoLogger = void 0;
const pino = require("pino");
const types_1 = require("@deepstream/types");
const DSToPino = {
    [types_1.LOG_LEVEL.DEBUG]: 'debug',
    [types_1.LOG_LEVEL.FATAL]: 'fatal',
    [types_1.LOG_LEVEL.ERROR]: 'error',
    [types_1.LOG_LEVEL.WARN]: 'warn',
    [types_1.LOG_LEVEL.INFO]: 'info',
};
class PinoLogger extends types_1.DeepstreamPlugin {
    constructor(pluginOptions, services) {
        super();
        this.services = services;
        this.description = 'Pino Logger';
        this.logger = pino();
    }
    /**
     * Return true if logging is enabled. This is used in deepstream to stop generating useless complex strings
     * that we know will never be logged.
     */
    shouldLog(logLevel) {
        return this.logger.isLevelEnabled(DSToPino[logLevel]);
    }
    /**
     * Set the log level desired by deepstream. Since deepstream uses LOG_LEVEL this needs to be mapped
     * to whatever your libary uses (this is usually just conversion stored in a static map)
     */
    setLogLevel(logLevel) {
        this.logger.level = DSToPino[logLevel];
    }
    /**
     * Log as info
     */
    info(event, message, metaData) {
        if (metaData) {
            this.logger.info({ ...metaData, message, event });
        }
        else {
            this.logger.info({ message, event });
        }
    }
    /**
     * Log as debug
     */
    debug(event, message, metaData) {
        if (metaData) {
            this.logger.debug({ ...metaData, message, event, });
        }
        else {
            this.logger.debug({ message, event });
        }
    }
    /**
     * Log as warn
     */
    warn(event, message, metaData) {
        if (metaData) {
            this.logger.warn({ ...metaData, message, event, });
        }
        else {
            this.logger.warn({ message, event });
        }
    }
    /**
     * Log as error
     */
    error(event, message, metaData) {
        if (metaData) {
            this.logger.error({ ...metaData, message, event, });
        }
        else {
            this.logger.error({ message, event });
        }
    }
    /**
     * Log as error
     */
    fatal(event, message, metaData) {
        if (metaData) {
            this.logger.fatal({ ...metaData, message, event, });
        }
        else {
            this.logger.fatal({ message, event });
        }
        this.services.notifyFatalException();
    }
    /**
     * Create a namespaced logger, used by plugins. This could either be a new instance of a logger
     * or just a thin wrapper to add the namespace at the beginning of the log method.
     */
    getNameSpace(namespace) {
        return {
            shouldLog: this.shouldLog.bind(this),
            fatal: this.log.bind(this, DSToPino[types_1.LOG_LEVEL.FATAL], namespace),
            error: this.log.bind(this, DSToPino[types_1.LOG_LEVEL.ERROR], namespace),
            warn: this.log.bind(this, DSToPino[types_1.LOG_LEVEL.WARN], namespace),
            info: this.log.bind(this, DSToPino[types_1.LOG_LEVEL.INFO], namespace),
            debug: this.log.bind(this, DSToPino[types_1.LOG_LEVEL.DEBUG], namespace),
        };
    }
    log(logLevel, namespace, event, message) {
        this.logger[logLevel]({ namespace, event, message });
    }
}
exports.PinoLogger = PinoLogger;
//# sourceMappingURL=pino-logger.js.map