import { TOPIC } from '../../constants';
import { DeepstreamServices, StateRegistry, StateRegistryCallback, DeepstreamConfig } from '@deepstream/types';
export declare type DistributedStateRegistryOptions = any;
/**
 * This class provides a generic mechanism that allows to maintain
 * a distributed state amongst the nodes of a cluster. The state is an
 * array of unique strings in arbitrary order.
 *
 * Whenever a string is added by any node within the cluster for the first time,
 * an 'add' event is emitted. Whenever its removed by the last node within the cluster,
 * a 'remove' event is emitted.
 */
export declare class DistributedStateRegistry implements StateRegistry {
    private topic;
    private stateOptions;
    private services;
    private config;
    private isReady;
    private data;
    private reconciliationTimeouts;
    private checkSumTimeouts;
    private fullStateSent;
    private initialServers;
    private emitter;
    private logger;
    /**
     * Initializes the DistributedStateRegistry and subscribes to the provided cluster topic
     */
    constructor(topic: TOPIC, stateOptions: any, services: Readonly<DeepstreamServices>, config: Readonly<DeepstreamConfig>);
    whenReady(): Promise<void>;
    onAdd(callback: StateRegistryCallback): void;
    onRemove(callback: StateRegistryCallback): void;
    /**
     * Checks if a given entry exists within the registry
     */
    has(name: string): boolean;
    /**
     * Add a name/entry to the registry. If the entry doesn't exist yet,
     * this will notify the other nodes within the cluster
     */
    add(name: string): void;
    /**
     * Removes a name/entry from the registry. If the entry doesn't exist,
     * this will exit silently
     */
    remove(name: string): void;
    removeAll(serverName: string): void;
    /**
     * Informs the distributed state registry a server has been added to the cluster
     */
    onServerAdded(serverName: string): void;
    /**
     * Removes all entries for a given serverName. This is intended to be called
     * whenever a node is removed from the cluster
     */
    onServerRemoved(serverName: string): void;
    /**
     * Returns all the servers that hold a given state
     */
    getAllServers(name: string): string[];
    /**
     * Returns all currently registered entries
     */
    getAll(serverName: string): string[];
    /**
     * Removes an entry for a given serverName. If the serverName
     * was the last node that held the entry, the entire entry will
     * be removed and a `remove` event will be emitted
     */
    private removeFromServer;
    /**
     * Adds a new entry to this registry, either as a result of a remote or
     * a local addition. Will emit an `add` event if the entry wasn't present before
     */
    private addToServer;
    /**
     * Generic messaging function for add and remove messages
     */
    private sendMessage;
    /**
     * This method calculates the total checkSum for all local entries of
     * a given serverName
     */
    private getCheckSumTotal;
    /**
     * Calculates a simple checkSum for a given name. This is done up-front and cached
     * to increase performance for local add and remove operations. Arguably this is a generic
     * method and might be moved to the utils class if we find another usecase for it.
     */
    private createCheckSum;
    /**
     * Checks a remote checkSum for a given serverName against the
     * actual checksum for all local entries for the given name.
     *
     * - If the checksums match, it removes all possibly pending
     *   reconciliationTimeouts
     *
     * - If the checksums don't match, it schedules a reconciliation request. If
     *   another message from the remote server arrives before the reconciliation request
     *   is send, it will be cancelled.
     */
    private verifyCheckSum;
    /**
     * Sends a reconciliation request for a server with a given name (technically, its send to
     * every node within the cluster, but will be ignored by all but the one with a matching name)
     *
     * The matching node will respond with a DISTRIBUTED_STATE_FULL_STATE message
     */
    private _requestFullState;
    /**
     * Creates a full state message containing an array of all local entries that
     * will be used to reconcile compromised states as well as provide the full state
     * for new nodes that joined the cluster
     *
     * When a state gets compromised, more than one remote registry might request a full state update.
     * This method will  schedule a timeout in which no additional full state messages are sent to
     * make sure only a single full state message is sent in reply.
     */
    sendFullState(serverName: string): void;
    /**
     * This will apply the data from an incoming full state message. Entries that are not within
     * the incoming array will be removed for that node from the local registry and new entries will
     * be added.
     */
    private applyFullState;
    /**
     * Will be called after a full state message has been sent and
     * stateReconciliationTimeout has passed. This will allow further reconciliation
     * messages to be sent again.
     */
    private resetFullStateSent;
    /**
     * This is the main routing point for messages coming in from
     * the message connector.
     */
    private processIncomingMessage;
}
