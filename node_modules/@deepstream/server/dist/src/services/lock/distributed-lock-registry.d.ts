import { DeepstreamPlugin, DeepstreamLockRegistry, DeepstreamServices, DeepstreamConfig, LockCallback } from '@deepstream/types';
/**
 * The lock registry is responsible for maintaing a single source of truth
 * within the cluster, used mainly for issuing cluster wide locks when an operation
 * that stretches over multiple nodes are required.
 *
 * For example, distributed listening requires a leader to drive the nodes in sequence,
 * so issuing a lock prevents multiple nodes from assuming the lead.
 *
 */
export declare class DistributedLockRegistry extends DeepstreamPlugin implements DeepstreamLockRegistry {
    private pluginOptions;
    private services;
    private config;
    description: string;
    private locks;
    private timeouts;
    private responseEventEmitter;
    /**
     * The unique registry is a singleton and is only created once
     * within deepstream.io. It is passed via
     * via the options object.
     */
    constructor(pluginOptions: any, services: Readonly<DeepstreamServices>, config: Readonly<DeepstreamConfig>);
    init(): void;
    /**
     * Requests a lock, if the leader ( whether local or distributed ) has the lock availble
     * it will invoke the callback with true, otherwise false.
     */
    get(lockName: string, callback: LockCallback): void;
    /**
     * Release a lock, allowing other resources to request it again
     */
    release(lockName: string): void;
    /**
     * Called when the current node is not the leader, issuing a lock request
     * via the message bus
     */
    private getRemoteLock;
    /**
     * Notifies a remote leader keeping a lock that said lock is no longer required
     */
    private releaseRemoteLock;
    /**
     * Called when a message is received on the message bus.
     * This could mean the leader responded to a request or that you're currently
     * the leader and received a request.
     */
    private onPrivateMessage;
    /**
     * Called when a remote lock request is received
     */
    private handleRemoteLockRequest;
    /**
     * Called when a remote lock response is received
     */
    private handleRemoteLockResponse;
    /**
     * Returns true if reserving lock was possible otherwise returns false
     */
    private getLock;
    /**
     * Called when a lock is no longer required and can be released. This is triggered either by
     * a timeout if a remote release message wasn't received in time or when release was called
     * locally.
     *
     * Important note: Anyone can release a lock. It is assumed that the cluster is trusted
     * so maintaining who has the lock is not required. This may need to change going forward.
     */
    private releaseLock;
    /**
     * Called when a timeout occurs on a lock that has been reserved for too long
     */
    private onLockTimeout;
    /**
     * Called when a remote request has timed out, resulting in notifying the client that
     * the lock wasn't able to be reserved
     */
    private onLockRequestTimeout;
}
