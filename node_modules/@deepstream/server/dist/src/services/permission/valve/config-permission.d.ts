import { Message } from '../../../constants';
import RecordHandler from '../../../handlers/record/record-handler';
import { DeepstreamPlugin, DeepstreamPermission, ValveConfig, DeepstreamServices, DeepstreamConfig, PermissionCallback, SocketWrapper, ValveSchema } from '@deepstream/types';
export declare type RuleType = string;
export declare type ValveSection = string;
export declare class ConfigPermission extends DeepstreamPlugin implements DeepstreamPermission {
    private permissionOptions;
    private services;
    private config;
    description: string;
    private ruleCache;
    private permissions;
    private recordHandler;
    private logger;
    /**
     * A permission handler that reads a rules config YAML or JSON, validates
     * its contents, compiles it and executes the permissions that it contains
     * against every incoming message.
     *
     * This is the standard permission handler that deepstream exposes, in conjunction
     * with the default permission.yml it allows everything, but at the same time provides
     * a convenient starting point for permission declarations.
     */
    constructor(permissionOptions: ValveConfig, services: Readonly<DeepstreamServices>, config: Readonly<DeepstreamConfig>);
    whenReady(): Promise<void>;
    close(): Promise<void>;
    /**
     * Will be invoked with the initialized recordHandler instance by deepstream.io
     */
    setRecordHandler(recordHandler: RecordHandler): void;
    /**
     * Validates and compiles a loaded config. This can be called as the result
     * of a config being passed to the permission service upon initialization,
     * as a result of loadConfig or at runtime
     *
     * CLI useConfig <config>
     */
    useConfig(permissions: ValveSchema): void;
    /**
     * Implements the permission service's canPerformAction interface
     * method
     *
     * This is the main entry point for permissionOperations and will
     * be called for every incoming message. This method executes four steps
     *
     * - Check if the incoming message conforms to basic specs
     * - Check if the incoming message requires permissions
     * - Load the applicable permissions
     * - Apply them
     */
    canPerformAction(socketWrapper: SocketWrapper, message: Message, callback: PermissionCallback, passItOn: any): void;
    /**
     * Evaluates the rules within a section and returns the matching rule for a path.
     * Takes basic specificity (as deduced from the path length) into account and
     * caches frequently used rules for faster access
     */
    private getCompiledRulesForName;
}
