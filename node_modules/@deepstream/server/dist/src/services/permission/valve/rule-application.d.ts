import { Message, RECORD_ACTION, PRESENCE_ACTION, EVENT_ACTION, RPC_ACTION } from '../../../constants';
import { PermissionCallback, ValveConfig, SocketWrapper, DeepstreamConfig, DeepstreamServices, NamespacedLogger } from '@deepstream/types';
import RecordHandler from '../../../handlers/record/record-handler';
interface RuleApplicationParams {
    userId: string;
    serverData: any;
    path: string;
    ruleSpecification: any;
    message: Message;
    action: RECORD_ACTION | PRESENCE_ACTION | EVENT_ACTION | RPC_ACTION;
    regexp: RegExp;
    rule: any;
    name: string;
    permissionOptions: ValveConfig;
    logger: NamespacedLogger;
    recordHandler: RecordHandler;
    socketWrapper: SocketWrapper;
    config: DeepstreamConfig;
    services: DeepstreamServices;
    callback: PermissionCallback;
    passItOn: any;
}
export default class RuleApplication {
    private params;
    private isDestroyed;
    private runScheduled;
    private pathVars;
    private user;
    private readonly maxIterationCount;
    private readonly recordsData;
    private iterations;
    /**
     * This class handles the evaluation of a single rule. It creates
     * the required variables, injects them into the rule function and
     * runs the function recoursively until either all cross-references,
     * references to old or new data is loaded, it errors or the maxIterationCount
     * limit is exceeded
     */
    constructor(params: RuleApplicationParams);
    /**
     * Runs the rule function. This method is initially called when this class
     * is constructed and recoursively from thereon whenever the loading of a record
     * is completed
     */
    private run;
    /**
     * Callback if a rule has irrecoverably errored. Rule errors due to unresolved
     * crossreferences are allowed as long as a loading step is in progress
     */
    private onRuleError;
    /**
     * Called either asynchronously when data is successfully retrieved from the
     * cache or synchronously if its already present
     */
    private onLoadComplete;
    /**
     * Called whenever a storage or cache retrieval fails. Any kind of error during the
     * permission process is treated as a denied permission
     */
    private onLoadError;
    /**
     * Destroys this class and nulls down values to avoid
     * memory leaks
     */
    private destroy;
    /**
     * If data.someValue is used in the rule, this method retrieves or loads the
     * current data. This can mean different things, depending on the type of message
     *
     * the data arguments is supported for record read & write,
     * event publish and rpc request
     *
     * for event publish, record update and rpc request, the data is already provided
     * in the message and doesn't need to be loaded
     *
     * for record.patch, only a delta is part of the message. For the full data, the current value
     * is loaded and the patch applied on top
     */
    private getCurrentData;
    /**
     * Loads the records current data and applies the patch data onto it
     * to avoid users having to distuinguish between patches and updates
     */
    private getRecordPatchData;
    /**
     * Returns or loads the record's previous value. Only supported for record
     * write and read operations
     *
     * If getData encounters an error, the rule application might already be destroyed
     * at this point
     */
    private getOldData;
    /**
     * Compile the list of arguments that will be injected
     * into the permission function. This method is called
     * everytime the permission is run. This allows it to merge
     * patches and update the now timestamp
     */
    private getArguments;
    /**
     * Returns the data for the user variable. This is only done once
     * per rule as the user is not expected to change
     */
    private getUser;
    /**
     * Applies the compiled regexp for the path and extracts
     * the variables that will be made available as $variableName
     * within the rule
     *
     * This is only done once per rule as the path is not expected
     * to change
     */
    private getPathVars;
    /**
     * Returns true if all loading operations that are in progress have finished
     * and no run has been scheduled yet
     */
    private isReady;
    /**
     * Loads a record with a given name. This will either result in
     * a onLoadComplete or onLoadError call. This method should only
     * be called if the record is not already being loaded or present,
     * but I'll leave the additional safeguards in until absolutely sure.
     */
    private loadRecord;
    /**
     * Load the record data from the cache for permissioning. This method should be
     * called once the record is stable â€“ meaning there are no remaining writes
     * waiting to be written to the cache.
     */
    private createNewRecordRequest;
    /**
     * This method is passed to the rule function as _ to allow crossReferencing
     * of other records. Cross-references can be nested, leading to this method
     * being recoursively called until the either all cross references are loaded
     * or the rule has finally failed
     */
    private crossReference;
}
export {};
