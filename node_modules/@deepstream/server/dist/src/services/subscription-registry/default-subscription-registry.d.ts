import { EVENT_ACTION, RECORD_ACTION, RPC_ACTION, TOPIC, Message, BulkSubscriptionMessage, STATE_REGISTRY_TOPIC } from '../../constants';
import { SocketWrapper, DeepstreamConfig, DeepstreamServices, SubscriptionListener, SubscriptionRegistry } from '@deepstream/types';
export declare class DefaultSubscriptionRegistry implements SubscriptionRegistry {
    private pluginConfig;
    private services;
    private config;
    private topic;
    private sockets;
    private subscriptions;
    private subscriptionListener;
    private constants;
    private clusterSubscriptions;
    private actions;
    private logger;
    private invalidSockets;
    /**
     * A generic mechanism to handle subscriptions from sockets to topics.
     * A bit like an event-hub, only that it registers SocketWrappers rather
     * than functions
     */
    constructor(pluginConfig: any, services: Readonly<DeepstreamServices>, config: Readonly<DeepstreamConfig>, topic: TOPIC | STATE_REGISTRY_TOPIC, clusterTopic: TOPIC);
    whenReady(): Promise<void>;
    close(): Promise<void>;
    /**
     * Return all the servers that have this subscription.
     */
    getAllServers(subscriptionName: string): string[];
    /**
     * Return all the servers that have this subscription excluding the current
     * server name
     */
    getAllRemoteServers(subscriptionName: string): string[];
    /**
     * Returns a list of all the topic this registry
     * currently has subscribers for
     */
    getNames(): string[];
    /**
     * Returns true if the subscription exists somewhere
     * in the cluster
     */
    hasName(subscriptionName: string): boolean;
    /**
    * This method allows you to customise the SubscriptionRegistry so that it can send
    * custom events and ack messages back.
    * For example, when using the ACTIONS.LISTEN, you would override SUBSCRIBE with
    * ACTIONS.SUBSCRIBE and UNSUBSCRIBE with UNSUBSCRIBE
    */
    setAction(name: string, value: EVENT_ACTION | RECORD_ACTION | RPC_ACTION): void;
    /**
     * Enqueues a message string to be broadcast to all subscribers. Broadcasts will potentially
     * be reordered in relation to *other* subscription names, but never in relation to the same
     * subscription name.
     */
    sendToSubscribers(name: string, message: Message, noDelay: boolean, senderSocket: SocketWrapper | null, suppressRemote?: boolean): void;
    /**
     * Adds a SocketWrapper as a subscriber to a topic
     */
    subscribeBulk(message: BulkSubscriptionMessage, socket: SocketWrapper, silent?: boolean): void;
    /**
     * Adds a SocketWrapper as a subscriber to a topic
     */
    unsubscribeBulk(message: BulkSubscriptionMessage, socket: SocketWrapper, silent?: boolean): void;
    /**
     * Adds a SocketWrapper as a subscriber to a topic
     */
    subscribe(name: string, message: Message, socket: SocketWrapper, silent?: boolean): void;
    /**
     * Removes a SocketWrapper from the list of subscriptions for a topic
     */
    unsubscribe(name: string, message: Message, socket: SocketWrapper, silent?: boolean): void;
    /**
     * Returns an array of SocketWrappers that are subscribed
     * to <name> or null if there are no subscribers
     */
    getLocalSubscribers(name: string): Set<SocketWrapper>;
    /**
     * Returns true if there are SocketWrappers that
     * are subscribed to <name> or false if there
     * aren't any subscribers
     */
    hasLocalSubscribers(name: string): boolean;
    /**
     * Allows to set a subscriptionListener after the class had been instantiated
     */
    setSubscriptionListener(listener: SubscriptionListener): void;
    private addSocket;
    private removeSocket;
    /**
    * Called whenever a socket closes to remove all of its subscriptions
    */
    private onSocketClose;
    private illegalCleanup;
}
