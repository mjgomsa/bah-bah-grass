"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MonitoringBase = void 0;
const messages_1 = require("@deepstream/protobuf/dist/types/messages");
const all_1 = require("@deepstream/protobuf/dist/types/all");
const types_1 = require("@deepstream/types");
class MonitoringBase extends types_1.DeepstreamPlugin {
    constructor(services) {
        super();
        this.services = services;
        this.errorLogs = {};
        this.receiveStats = {};
        this.sendStats = {};
        this.loginStats = {};
    }
    onErrorLog(loglevel, event, logMessage) {
        const count = this.errorLogs[event];
        if (!count) {
            this.errorLogs[event] = 1;
        }
        else {
            this.errorLogs[event] = count + 1;
        }
    }
    /**
     * Called whenever a login attempt is tried and whether or not it succeeded, as well
     * as the connection-endpoint type, which is provided from the connection endpoint
     * itself
     */
    onLogin(allowed, endpointType) {
        let stats = this.loginStats[endpointType];
        if (!stats) {
            stats = { allowed: 0, declined: 0 };
            this.loginStats[endpointType] = stats;
        }
        allowed ? stats.allowed++ : stats.declined++;
    }
    onMessageReceived(message) {
        let actionsMap = this.receiveStats[all_1.TOPIC[message.topic]];
        if (!actionsMap) {
            actionsMap = {};
            this.receiveStats[all_1.TOPIC[message.topic]] = actionsMap;
        }
        const actionName = messages_1.ACTIONS[message.topic][message.action];
        actionsMap[actionName] = actionsMap[actionName] ? actionsMap[actionName] + 1 : 1;
    }
    onMessageSend(message) {
        let actionsMap = this.sendStats[all_1.TOPIC[message.topic]];
        if (!actionsMap) {
            actionsMap = {};
            this.sendStats[all_1.TOPIC[message.topic]] = actionsMap;
        }
        const actionName = messages_1.ACTIONS[message.topic][message.action];
        actionsMap[actionName] = actionsMap[actionName] ? actionsMap[actionName] + 1 : 1;
    }
    onBroadcast(message, count) {
        let actionsMap = this.receiveStats[all_1.TOPIC[message.topic]];
        if (!actionsMap) {
            actionsMap = {};
            this.sendStats[all_1.TOPIC[message.topic]] = actionsMap;
        }
        const actionName = messages_1.ACTIONS[message.topic][message.action];
        actionsMap[actionName] = actionsMap[actionName] ? actionsMap[actionName] + count : count;
    }
    getAndResetMonitoringStats() {
        const results = {
            clusterSize: this.services.clusterRegistry.getAll().length,
            stateMetrics: this.getStateMetrics(),
            errors: this.errorLogs,
            received: this.receiveStats,
            send: this.sendStats,
            logins: this.loginStats
        };
        this.errorLogs = {};
        this.receiveStats = {};
        this.sendStats = {};
        this.loginStats = {};
        return results;
    }
    getStateMetrics() {
        const result = {};
        const stateRegistries = this.services.clusterStates.getStateRegistries();
        for (const [topic, stateRegistry] of stateRegistries) {
            result[all_1.TOPIC[topic] || all_1.STATE_REGISTRY_TOPIC[topic]] = stateRegistry.getAll().length;
        }
        return result;
    }
}
exports.MonitoringBase = MonitoringBase;
//# sourceMappingURL=monitoring-base.js.map