/// <reference types="node" />
/**
 * Returns a unique identifier
 */
export declare let getUid: () => string;
/**
 * Takes a key-value map and returns
 * a map with { value: key } of the old map
 */
export declare let reverseMap: (map: any) => any;
/**
 * Extended version of the typeof operator. Also supports 'array'
 * and 'url' to check for valid URL schemas
 */
export declare let isOfType: (input: any, expectedType: string) => boolean;
/**
 * Takes a map and validates it against a basic
 * json schema in the form { key: type }
 * @returns {Boolean|Error}
 */
export declare let validateMap: (map: any, throwError: boolean, schema: any) => any;
/**
 * Multi Object recursive merge
 * @param {Object} multiple objects to be merged into each other recursively
 */
export declare let merge: (...args: any[]) => {};
export declare let getRandomIntInRange: (min: number, max: number) => number;
export declare let spliceRandomElement: (array: any[]) => any;
/**
 * Randomize array element order in-place.
 * Using Durstenfeld shuffle algorithm.
 */
export declare let shuffleArray: (array: any[]) => any[];
export declare let deepFreeze: (obj: any) => any;
/**
 * Check whether a record name should be excluded from storage
 */
export declare const isExcluded: (exclusionPrefixes: string[], recordName: string) => boolean;
export declare const PromiseDelay: (timeout: number) => Promise<unknown>;
/**
 * Utility method for creating hashes including salts based on
 * the provided parameters
 */
export declare const createHash: (password: string, settings: {
    iterations: number;
    keyLength: number;
    algorithm: string;
}, salt?: string) => Promise<{
    hash: Buffer;
    salt: string;
}>;
export declare const validateHashingAlgorithm: (hash: string) => void;
export declare const validateUUID: (uuid: string) => boolean;
