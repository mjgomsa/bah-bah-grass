import { TOPIC, ListenMessage } from '../constants';
import { SubscriptionListener, DeepstreamConfig, DeepstreamServices, SocketWrapper, SubscriptionRegistry } from '@deepstream/types';
export declare class ListenerRegistry implements SubscriptionListener {
    private topic;
    private config;
    private services;
    private clientRegistry;
    private metaData;
    private providerRegistry;
    private uniqueLockName;
    private patterns;
    private locallyProvidedRecords;
    private messageTopic;
    private actions;
    private listenInProgress;
    private unsuccesfulMatches;
    private clusterProvidedRecords;
    private rematchInterval;
    /**
    * Deepstream.io allows clients to register as listeners for subscriptions.
    * This allows for the creation of 'active' data-providers,
    * e.g. data providers that provide data on the fly, based on what clients
    * are actually interested in.
    *
    * When a client registers as a listener, it provides a regular expression.
    * It will then immediatly get a number of callbacks for existing record subscriptions
    * whose names match that regular expression.
    *
    * After that, whenever a record with a name matching that regular expression is subscribed
    * to for the first time, the listener is notified.
    *
    * Whenever the last subscription for a matching record is removed, the listener is also
    * notified with a SUBSCRIPTION_FOR_PATTERN_REMOVED action
    *
    * This class manages the matching of patterns and record names. The subscription /
    * notification logic is handled by this.providerRegistry
    */
    constructor(topic: TOPIC, config: DeepstreamConfig, services: DeepstreamServices, clientRegistry: SubscriptionRegistry, metaData?: any);
    close(): Promise<void>;
    /**
    * Returns whether or not a provider exists for
    * the specific subscriptionName
    */
    hasActiveProvider(susbcriptionName: string): boolean;
    /**
    * The main entry point to the handle class.
    * Called on any of the following actions:
    *
    * 1) ACTIONS.LISTEN
    * 2) ACTIONS.UNLISTEN
    * 3) ACTIONS.LISTEN_ACCEPT
    * 4) ACTIONS.LISTEN_REJECT
    */
    handle(socketWrapper: SocketWrapper, message: ListenMessage): void;
    /**
    * Handle messages that arrive via the message bus
    */
    private onIncomingMessage;
    /**
    * Process an accept or reject for a listen that is currently in progress
    * and hasn't timed out yet.
    */
    private processResponseForListenInProgress;
    /**
    * Called by the record subscription registry whenever a subscription count goes down to zero
    * Part of the subscriptionListener interface.
    */
    onFirstSubscriptionMade(subscriptionName: string): void;
    onSubscriptionMade(subscriptionName: string, socketWrapper: SocketWrapper): void;
    onLastSubscriptionRemoved(subscriptionName: string): void;
    /**
    * Called by the record subscription registry whenever the subscription count increments.
    * Part of the subscriptionListener interface.
    */
    onSubscriptionRemoved(subscriptionName: string, socketWrapper: SocketWrapper): void;
    /**
    * Register callback for when the server recieves an accept message from the client
    */
    private accept;
    /**
    * Register a client as a listener for record subscriptions
    */
    private addListener;
    /**
    * Find subscriptions that match pattern, and notify them that
    * they can be provided.
    *
    * We will attempt to notify all possible providers rather than
    * just the single provider for load balancing purposes and
    * so that the one listener doesnt potentially get overwhelmed.
    */
    private reconcileSubscriptionsToPatterns;
    /**
    * Removes the listener if it is the currently active publisher, and retriggers
    * another listener discovery phase
    */
    private removeListenerIfActive;
    /**
      */
    private removeActiveListener;
    /**
    * Start discovery phase once a lock is obtained from the leader within
    * the cluster
    */
    private startProviderSearch;
    /**
    * Start discovery phase once a lock is obtained from the leader within
    * the cluster
    */
    private startLocalDiscoveryStage;
    /**
    * Trigger the next provider in the map of providers capable of publishing
    * data to the specific subscriptionName
    */
    private triggerNextProvider;
    /**
    * Finalises a local listener discovery stage
    */
    private stopProviderSearch;
    /**
    * Triggered when a subscription is being provided by a node in the cluster
    */
    private onRecordStartProvided;
    /**
    * Triggered when a subscription is stopped being provided by a node in the cluster
    */
    private onRecordStopProvided;
    /**
    * Compiles a regular expression from an incoming pattern
    */
    private addPattern;
    /**
    * Deletes the pattern regex when removed
    */
    private removePattern;
    private removeLastPattern;
    /**
    * Remove provider from listen in progress map if it unlistens during discovery stage
    */
    private removeListenerFromInProgress;
    /**
    * Sends a has provider update to a single subcriber
    */
    private sendHasProviderUpdateToSingleSubscriber;
    /**
    * Sends a has provider update to all subcribers
    */
    private sendHasProviderUpdate;
    /**
    * Send a subscription found to a provider
    */
    private sendSubscriptionForPatternFound;
    /**
    * Send a subscription removed to a provider
    */
    private sendSubscriptionForPatternRemoved;
    /**
    * Create a map of all the listeners that patterns match the subscriptionName locally
    */
    private createLocalListenArray;
    /**
    * Validates that the pattern is not empty and is a valid regular expression
    */
    private validatePattern;
    /**
    * Returns the unique lock when leading a listen discovery phase
    */
    private getUniqueLockName;
}
