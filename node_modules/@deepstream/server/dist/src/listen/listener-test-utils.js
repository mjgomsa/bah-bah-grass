"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
require("mocha");
const chai_1 = require("chai");
const listener_registry_1 = require("./listener-registry");
const testHelper = require("../test/helper/test-helper");
const C = require("../constants");
const test_mocks_1 = require("../test/helper/test-mocks");
const sinon = require("sinon");
class ListenerTestUtils {
    constructor(listenerTopic) {
        this.subscribedTopics = [];
        this.subscribers = new Set();
        const { config, services } = testHelper.getDeepstreamOptions();
        this.topic = listenerTopic || C.TOPIC.RECORD;
        if (this.topic === C.TOPIC.RECORD) {
            this.actions = C.RECORD_ACTION;
        }
        else {
            this.actions = C.EVENT_ACTION;
        }
        const self = this;
        this.clientRegistry = {
            hasName(subscriptionName) {
                return self.subscribedTopics.indexOf(subscriptionName) === -1;
            },
            getNames() {
                return self.subscribedTopics;
            },
            getLocalSubscribers() {
                return self.subscribers;
            },
            hasLocalSubscribers() {
                return self.subscribers.size > 0;
            },
            sendToSubscribers: () => { }
        };
        this.clientRegistryMock = sinon.mock(this.clientRegistry);
        config.listen.responseTimeout = 30;
        config.listen.shuffleProviders = false;
        // config.stateReconciliationTimeout = 10
        this.clients = [
            // @ts-ignore
            null,
            test_mocks_1.getTestMocks().getSocketWrapper('c1'),
            test_mocks_1.getTestMocks().getSocketWrapper('c2'),
            test_mocks_1.getTestMocks().getSocketWrapper('c3')
        ];
        this.providers = [
            // @ts-ignore
            null,
            test_mocks_1.getTestMocks().getSocketWrapper('p1'),
            test_mocks_1.getTestMocks().getSocketWrapper('p2'),
            test_mocks_1.getTestMocks().getSocketWrapper('p3')
        ];
        this.listenerRegistry = new listener_registry_1.ListenerRegistry(self.topic, config, services, self.clientRegistry);
        chai_1.expect(typeof self.listenerRegistry.handle).to.equal('function');
    }
    complete() {
        this.clients.forEach((client) => {
            if (client) {
                client.socketWrapperMock.verify();
            }
        });
        this.providers.forEach((provider) => {
            if (provider) {
                provider.socketWrapperMock.verify();
            }
        });
        this.clientRegistryMock.verify();
    }
    /**
    * Provider Utils
    */
    providerListensTo(provider, pattern) {
        this.providers[provider].socketWrapperMock
            .expects('sendAckMessage')
            .once()
            .withExactArgs({
            topic: this.topic,
            action: this.actions.LISTEN,
            name: pattern
        });
        this.listenerRegistry.handle(this.providers[provider].socketWrapper, {
            topic: this.topic,
            action: this.actions.LISTEN,
            name: pattern
        });
    }
    providerUnlistensTo(provider, pattern) {
        this.providers[provider].socketWrapperMock
            .expects('sendAckMessage')
            .once()
            .withExactArgs({
            topic: this.topic,
            action: this.actions.UNLISTEN,
            name: pattern
        });
        this.listenerRegistry.handle(this.providers[provider].socketWrapper, {
            topic: this.topic,
            action: this.actions.UNLISTEN,
            name: pattern,
        });
    }
    providerWillGetListenTimeout(provider, subscription) {
        this.providers[provider].socketWrapperMock
            .expects('sendMessage')
            .once()
            .withExactArgs({
            topic: this.topic,
            action: this.actions.LISTEN_RESPONSE_TIMEOUT,
            subscription
        });
    }
    providerWillGetSubscriptionFound(provider, pattern, subscription) {
        this.providers[provider].socketWrapperMock
            .expects('sendMessage')
            .once()
            .withExactArgs({
            topic: this.topic,
            action: this.actions.SUBSCRIPTION_FOR_PATTERN_FOUND,
            name: pattern,
            subscription
        });
    }
    providerWillGetSubscriptionRemoved(provider, pattern, subscription) {
        this.providers[provider].socketWrapperMock
            .expects('sendMessage')
            .once()
            .withExactArgs({
            topic: this.topic,
            action: this.actions.SUBSCRIPTION_FOR_PATTERN_REMOVED,
            name: pattern,
            subscription
        });
    }
    providerAcceptsButIsntAcknowledged(provider, pattern, subscriptionName) {
        this.providerAccepts(provider, pattern, subscriptionName, true);
    }
    providerAccepts(provider, pattern, subscription, doesnthaveActiveProvider) {
        this.listenerRegistry.handle(this.providers[provider].socketWrapper, {
            topic: this.topic,
            action: this.actions.LISTEN_ACCEPT,
            name: pattern,
            subscription
        });
        chai_1.expect(this.listenerRegistry.hasActiveProvider(subscription)).to.equal(!doesnthaveActiveProvider);
    }
    providerRejectsAndPreviousTimeoutProviderThatAcceptedIsUsed(provider, pattern, subscriptionName) {
        this.providerRejects(provider, pattern, subscriptionName, true);
    }
    providerAcceptsAndIsSentSubscriptionRemoved(provider, pattern, subscriptionName) {
        this.providerWillGetSubscriptionRemoved(provider, pattern, subscriptionName);
        this.providerAcceptsButIsntAcknowledged(provider, pattern, subscriptionName);
    }
    providerRejects(provider, pattern, subscription, doNotCheckActiveProvider) {
        this.listenerRegistry.handle(this.providers[provider].socketWrapper, {
            topic: this.topic,
            action: this.actions.LISTEN_REJECT,
            name: pattern,
            subscription
        });
        if (!doNotCheckActiveProvider) {
            chai_1.expect(this.listenerRegistry.hasActiveProvider(subscription)).to.equal(false);
        }
    }
    acceptMessageThrowsError(provider, pattern, subscription) {
        this.listenerRegistry.handle(this.providers[provider].socketWrapper, {
            topic: this.topic,
            action: this.actions.LISTEN_ACCEPT,
            name: pattern,
            subscription
        });
        // verify( providers[ provider], this.actions.ERROR, [ C.EVENT.INVALID_MESSAGE, this.actions.LISTEN_ACCEPT, pattern, subscriptionName ] );
    }
    rejectMessageThrowsError(provider, pattern, subscription) {
        this.listenerRegistry.handle(this.providers[provider].socketWrapper, {
            topic: this.topic,
            action: this.actions.LISTEN_REJECT,
            name: pattern,
            subscription
        });
        // TODO
        // verify( providers[ provider], this.actions.ERROR, [ C.EVENT.INVALID_MESSAGE, this.actions.LISTEN_REJECT, pattern, subscriptionName ] );
    }
    providerLosesItsConnection(provider) {
        // (this.providers[provider].socketWrapper as any).emit('close', this.providers[provider].socketWrapper)
    }
    /**
    * Subscriber Utils
    */
    subscriptionAlreadyMadeFor(subscriptionName) {
        this.subscribedTopics.push(subscriptionName);
    }
    clientSubscribesTo(client, subscriptionName, firstSubscription) {
        if (firstSubscription) {
            this.listenerRegistry.onFirstSubscriptionMade(subscriptionName);
        }
        this.listenerRegistry.onSubscriptionMade(subscriptionName, this.clients[client].socketWrapper);
        this.subscribedTopics.push(subscriptionName);
        this.subscribers.add(this.clients[client].socketWrapper);
    }
    clientUnsubscribesTo(client, subscriptionName, lastSubscription) {
        if (lastSubscription) {
            this.listenerRegistry.onLastSubscriptionRemoved(subscriptionName);
        }
        this.listenerRegistry.onSubscriptionRemoved(subscriptionName, this.clients[client].socketWrapper);
        this.subscribedTopics.splice(this.subscribedTopics.indexOf(subscriptionName), 1);
        this.subscribers.delete(this.clients[client].socketWrapper);
    }
    clientWillRecievePublishedUpdate(client, subscription, state) {
        this.clients[client].socketWrapperMock
            .expects('sendMessage')
            .once()
            .withExactArgs({
            topic: this.topic,
            action: state ? this.actions.SUBSCRIPTION_HAS_PROVIDER : this.actions.SUBSCRIPTION_HAS_NO_PROVIDER,
            name: subscription,
        });
    }
    publishUpdateWillBeSentToSubscribers(subscription, state) {
        this.clientRegistryMock
            .expects('sendToSubscribers')
            .once()
            .withExactArgs(subscription, {
            topic: this.topic,
            action: state ? this.actions.SUBSCRIPTION_HAS_PROVIDER : this.actions.SUBSCRIPTION_HAS_NO_PROVIDER,
            name: subscription,
        }, false, null);
    }
    subscriptionHasActiveProvider(subscription, value) {
        chai_1.expect(this.listenerRegistry.hasActiveProvider(subscription)).to.equal(value);
    }
}
exports.default = ListenerTestUtils;
//# sourceMappingURL=listener-test-utils.js.map