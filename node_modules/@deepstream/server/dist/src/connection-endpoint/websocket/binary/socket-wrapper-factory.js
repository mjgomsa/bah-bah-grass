"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createWSSocketWrapper = exports.WSBinarySocketWrapper = void 0;
const binaryMessageBuilder = require("@deepstream/protobuf/dist/src/message-builder");
const binaryMessageParser = require("@deepstream/protobuf/dist/src/message-parser");
const socket_wrapper_1 = require("../../base/socket-wrapper");
class WSBinarySocketWrapper extends socket_wrapper_1.WSSocketWrapper {
    constructor() {
        super(...arguments);
        this.socketType = 'wsBinary';
    }
    getAckMessage(message) {
        return binaryMessageBuilder.getMessage(message, true);
    }
    getMessage(message) {
        return binaryMessageBuilder.getMessage(message, false);
    }
    parseMessage(message) {
        if (typeof message === 'string') {
            this.invalidTypeReceived();
            return [];
        }
        /* we copy the underlying buffer (since a shallow reference won't be safe
         * outside of the callback)
         * the copy could be avoided if we make sure not to store references to the
         * raw buffer within the message
         */
        return binaryMessageParser.parse(Buffer.from(Buffer.from(message)));
    }
    parseData(message) {
        return binaryMessageParser.parseData(message);
    }
}
exports.WSBinarySocketWrapper = WSBinarySocketWrapper;
const createWSSocketWrapper = function (socket, handshakeData, services, config, connectionEndpoint) { return new WSBinarySocketWrapper(socket, handshakeData, services, config, connectionEndpoint, true); };
exports.createWSSocketWrapper = createWSSocketWrapper;
//# sourceMappingURL=socket-wrapper-factory.js.map