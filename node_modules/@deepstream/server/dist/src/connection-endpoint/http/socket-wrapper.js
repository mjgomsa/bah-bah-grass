"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const message_parser_1 = require("@deepstream/protobuf/dist/src/message-parser");
const events_1 = require("events");
class HTTPSocketWrapper extends events_1.EventEmitter {
    constructor(services, onMessageCallback, onErrorCallback) {
        super();
        this.services = services;
        this.onMessageCallback = onMessageCallback;
        this.onErrorCallback = onErrorCallback;
        this.socketType = 'http';
        this.userId = null;
        this.serverData = null;
        this.clientData = null;
        this.uuid = Math.random();
        this.correlationIndex = -1;
        this.messageResults = [];
        this.responseCallback = null;
        this.requestTimeout = null;
        this.authCallback = null;
        this.isRemote = false;
        this.isClosed = false;
        // TODO: This isn't used here but is part of a stateful socketWrapper
        this.authAttempts = 0;
    }
    init(authResponseData, messageIndex, messageResults, responseCallback, requestTimeoutId) {
        this.userId = authResponseData.id || 'OPEN';
        this.clientData = authResponseData.clientData || null;
        this.serverData = authResponseData.serverData || null;
        this.correlationIndex = messageIndex;
        this.messageResults = messageResults;
        this.responseCallback = responseCallback;
        this.requestTimeout = requestTimeoutId;
    }
    close() {
        this.isClosed = true;
    }
    flush() {
    }
    onMessage() {
    }
    getMessage() {
    }
    /**
     * Returns a map of parameters that were collected
     * during the initial http request that established the
     * connection
     */
    getHandshakeData() {
        return {};
    }
    /**
     * Sends an error on the specified topic. The
     * action will automatically be set to C.ACTION.ERROR
     */
    sendError(message, event, errorMessage) {
        if (this.isClosed === false) {
            message_parser_1.parseData(message);
            this.onErrorCallback(this.messageResults, this.correlationIndex, message, event, errorMessage, this.responseCallback, this.requestTimeout);
        }
    }
    /**
     * Sends a message based on the provided action and topic
     */
    sendMessage(message) {
        if (message.action >= 100) {
            message.isError = true;
        }
        if (this.isClosed === false) {
            this.services.monitoring.onMessageSend(message);
            message_parser_1.parseData(message);
            this.onMessageCallback(this.messageResults, this.correlationIndex, message, this.responseCallback, this.requestTimeout);
        }
    }
    sendAckMessage(message) {
        message.isAck = true;
        this.sendMessage(message);
    }
    parseData(message) {
        return message_parser_1.parseData(message);
    }
    parseMessage(serializedMessage) {
        throw new Error('Method not implemented.');
    }
    /**
     * Destroys the socket. Removes all deepstream specific
     * logic and closes the connection
     *
     * @public
     * @returns {void}
     */
    destroy() {
    }
    onClose() {
    }
    removeOnClose() {
    }
}
exports.default = HTTPSocketWrapper;
//# sourceMappingURL=socket-wrapper.js.map