/// <reference types="node" />
import { EventEmitter } from 'events';
import { DeepstreamServices, UnauthenticatedSocketWrapper, EVENT, DeepstreamAuthenticationResult } from '@deepstream/types';
import { Message, ParseResult } from '../../constants';
export default class HTTPSocketWrapper extends EventEmitter implements UnauthenticatedSocketWrapper {
    private services;
    private onMessageCallback;
    private onErrorCallback;
    socketType: string;
    userId: string | null;
    serverData: object | null;
    clientData: object | null;
    uuid: number;
    private correlationIndex;
    private messageResults;
    private responseCallback;
    private requestTimeout;
    authCallback: Function | null;
    isRemote: boolean;
    isClosed: boolean;
    authAttempts: number;
    constructor(services: DeepstreamServices, onMessageCallback: Function, onErrorCallback: Function);
    init(authResponseData: DeepstreamAuthenticationResult, messageIndex: number, messageResults: any[], responseCallback: Function, requestTimeoutId: NodeJS.Timeout): void;
    close(): void;
    flush(): void;
    onMessage(): void;
    getMessage(): void;
    /**
     * Returns a map of parameters that were collected
     * during the initial http request that established the
     * connection
     */
    getHandshakeData(): {};
    /**
     * Sends an error on the specified topic. The
     * action will automatically be set to C.ACTION.ERROR
     */
    sendError(message: Message, event: EVENT, errorMessage: string): void;
    /**
     * Sends a message based on the provided action and topic
     */
    sendMessage(message: Message): void;
    sendAckMessage(message: Message): void;
    parseData(message: Message): true | Error;
    parseMessage(serializedMessage: any): ParseResult[];
    /**
     * Destroys the socket. Removes all deepstream specific
     * logic and closes the connection
     *
     * @public
     * @returns {void}
     */
    destroy(): void;
    onClose(): void;
    removeOnClose(): void;
}
