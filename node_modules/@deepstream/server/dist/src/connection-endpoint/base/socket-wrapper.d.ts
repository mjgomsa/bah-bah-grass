import { TOPIC, CONNECTION_ACTION, ParseResult, Message } from '../../constants';
import { WebSocketServerConfig } from './connection-endpoint';
import { SocketConnectionEndpoint, StatefulSocketWrapper, DeepstreamServices, UnauthenticatedSocketWrapper } from '@deepstream/types';
export declare abstract class WSSocketWrapper<SerializedType extends {
    length: number;
}> implements UnauthenticatedSocketWrapper {
    private socket;
    private handshakeData;
    private services;
    private config;
    private connectionEndpoint;
    private isBinary;
    abstract socketType: string;
    isRemote: false;
    isClosed: boolean;
    uuid: number;
    authCallback: Function | null;
    authAttempts: number;
    lastMessageRecievedAt: number;
    private bufferedWrites;
    private closeCallbacks;
    userId: string | null;
    serverData: object | null;
    clientData: object | null;
    private bufferedWritesTotalByteSize;
    constructor(socket: any, handshakeData: any, services: DeepstreamServices, config: WebSocketServerConfig, connectionEndpoint: SocketConnectionEndpoint, isBinary: boolean);
    get isOpen(): boolean;
    protected invalidTypeReceived(): void;
    /**
     * Called by the connection endpoint to flush all buffered writes.
     * A buffered write is a write that is not a high priority, such as an ack
     * and can wait to be bundled into another message if necessary
     */
    flush(): void;
    /**
     * Sends a message based on the provided action and topic
     */
    sendMessage(message: {
        topic: TOPIC;
        action: CONNECTION_ACTION;
    } | Message, allowBuffering?: boolean): void;
    /**
     * Sends a message based on the provided action and topic
     */
    sendAckMessage(message: Message, allowBuffering?: boolean): void;
    abstract getMessage(message: Message): SerializedType;
    abstract getAckMessage(message: Message): SerializedType;
    abstract parseMessage(message: SerializedType): ParseResult[];
    abstract parseData(message: Message): true | Error;
    onMessage(messages: Message[]): void;
    /**
     * Destroys the socket. Removes all deepstream specific
     * logic and closes the connection
     */
    destroy(): void;
    close(): void;
    /**
     * Returns a map of parameters that were collected
     * during the initial http request that established the
     * connection
     */
    getHandshakeData(): any;
    onClose(callback: (socketWrapper: StatefulSocketWrapper) => void): void;
    removeOnClose(callback: (socketWrapper: StatefulSocketWrapper) => void): void;
    sendBuiltMessage(message: SerializedType, buffer?: boolean): void;
    protected writeMessage(socket: any, message: SerializedType): void;
}
