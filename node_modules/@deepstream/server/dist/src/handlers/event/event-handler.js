"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const constants_1 = require("../../constants");
const listener_registry_1 = require("../../listen/listener-registry");
const types_1 = require("@deepstream/types");
class EventHandler {
    /**
     * Handles incoming and outgoing messages for the EVENT topic.
     */
    constructor(config, services, subscriptionRegistry, listenerRegistry) {
        this.services = services;
        this.subscriptionRegistry =
            subscriptionRegistry || services.subscriptions.getSubscriptionRegistry(constants_1.TOPIC.EVENT, constants_1.STATE_REGISTRY_TOPIC.EVENT_SUBSCRIPTIONS);
        this.listenerRegistry =
            listenerRegistry || new listener_registry_1.ListenerRegistry(constants_1.TOPIC.EVENT, config, services, this.subscriptionRegistry, null);
        this.subscriptionRegistry.setSubscriptionListener(this.listenerRegistry);
    }
    async close() {
        this.listenerRegistry.close();
    }
    /**
     * The main distribution method. Routes messages to functions
     * based on the provided action parameter of the message
     */
    handle(socketWrapper, message) {
        if (message.action === constants_1.EVENT_ACTION.EMIT) {
            this.triggerEvent(socketWrapper, message);
            return;
        }
        if (socketWrapper === null) {
            this.services.logger.error(types_1.EVENT.ERROR, 'missing socket wrapper');
            return;
        }
        if (message.action === constants_1.EVENT_ACTION.SUBSCRIBE) {
            this.subscriptionRegistry.subscribeBulk(message, socketWrapper);
            return;
        }
        if (message.action === constants_1.EVENT_ACTION.UNSUBSCRIBE) {
            this.subscriptionRegistry.unsubscribeBulk(message, socketWrapper);
            return;
        }
        if (message.action === constants_1.EVENT_ACTION.LISTEN ||
            message.action === constants_1.EVENT_ACTION.UNLISTEN ||
            message.action === constants_1.EVENT_ACTION.LISTEN_ACCEPT ||
            message.action === constants_1.EVENT_ACTION.LISTEN_REJECT) {
            this.listenerRegistry.handle(socketWrapper, message);
            return;
        }
        console.log('unknown action', message);
    }
    /**
     * Notifies subscribers of events. This method is invoked for the EVENT action. It can
     * be triggered by messages coming in from both clients and the message connector.
     */
    triggerEvent(socket, message) {
        this.services.logger.debug(constants_1.EVENT_ACTION[constants_1.EVENT_ACTION.EMIT], `event: ${message.name} with data: ${message.data}`);
        this.subscriptionRegistry.sendToSubscribers(message.name, message, false, socket);
    }
}
exports.default = EventHandler;
//# sourceMappingURL=event-handler.js.map