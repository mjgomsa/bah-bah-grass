"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RpcProxy = void 0;
const constants_1 = require("../../constants");
/**
 * This class exposes an interface that mimicks the behaviour
 * of a SocketWrapper, connected to a local rpc provider, but
 * infact relays calls from and to the message connector - sneaky.
 */
class RpcProxy {
    constructor(config, services, remoteServer, metaData) {
        this.services = services;
        this.remoteServer = remoteServer;
        this.metaData = metaData;
        this.socketType = 'RpcProxy';
        this.userId = 'remote server ' + this.remoteServer;
        this.clientData = null;
        this.serverData = null;
        this.isRemote = true;
    }
    sendAckMessage(message) {
    }
    /**
    * Mimicks the SocketWrapper's send method, but expects a message object,
    * instead of a string.
    *
    * Adds additional information to the message that enables the counterparty
    * to identify the sender
    */
    sendMessage(msg) {
        this.services.clusterNode.sendDirect(this.remoteServer, msg, this.metaData);
    }
    /**
    * Mimicks the SocketWrapper's sendError method.
    * Sends an error on the specified topic. The
    * action will automatically be set to ACTION.ERROR
    */
    sendError(msg, type, errorMessage) {
        if (type === constants_1.RPC_ACTION.RESPONSE_TIMEOUT) {
            // by the time an RPC has timed out on this server, it has already timed out on the remote
            // (and has been cleaned up) so no point sending
            return;
        }
        this.services.clusterNode.sendDirect(this.remoteServer, msg, this.metaData);
    }
    parseMessage(serializedMessage) {
        throw new Error('Method not implemented.');
    }
}
exports.RpcProxy = RpcProxy;
//# sourceMappingURL=rpc-proxy.js.map