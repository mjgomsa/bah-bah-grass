"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const constants_1 = require("../../constants");
const types_1 = require("@deepstream/types");
const EVERYONE = '%_EVERYONE_%';
/**
 * This class handles incoming and outgoing messages in relation
 * to deepstream presence. It provides a way to inform clients
 * who else is logged into deepstream
 */
class PresenceHandler extends types_1.Handler {
    constructor(config, services, subscriptionRegistry, stateRegistry, metaData) {
        super();
        this.services = services;
        this.metaData = metaData;
        this.localClients = new Map();
        this.subscriptionRegistry =
            subscriptionRegistry || services.subscriptions.getSubscriptionRegistry(constants_1.TOPIC.PRESENCE, constants_1.STATE_REGISTRY_TOPIC.PRESENCE_SUBSCRIPTIONS);
        this.connectedClients =
            stateRegistry || this.services.clusterStates.getStateRegistry(constants_1.STATE_REGISTRY_TOPIC.ONLINE_USERS);
        this.connectedClients.onAdd(this.onClientAdded.bind(this));
        this.connectedClients.onRemove(this.onClientRemoved.bind(this));
    }
    /**
    * The main entry point to the presence handler class.
    *
    * Handles subscriptions, unsubscriptions and queries
    */
    handle(socketWrapper, message) {
        if (message.action === constants_1.PRESENCE_ACTION.QUERY_ALL) {
            this.handleQueryAll(message.correlationId, socketWrapper);
            return;
        }
        if (message.action === constants_1.PRESENCE_ACTION.SUBSCRIBE_ALL) {
            this.subscriptionRegistry.subscribe(EVERYONE, {
                topic: constants_1.TOPIC.PRESENCE,
                action: constants_1.PRESENCE_ACTION.SUBSCRIBE_ALL,
                name: EVERYONE
            }, socketWrapper, true);
            socketWrapper.sendAckMessage({
                topic: message.topic,
                action: message.action
            });
            return;
        }
        if (message.action === constants_1.PRESENCE_ACTION.UNSUBSCRIBE_ALL) {
            this.subscriptionRegistry.unsubscribe(EVERYONE, {
                topic: constants_1.TOPIC.PRESENCE,
                action: constants_1.PRESENCE_ACTION.UNSUBSCRIBE_ALL,
                name: EVERYONE
            }, socketWrapper, true);
            socketWrapper.sendAckMessage({
                topic: message.topic,
                action: message.action
            });
            return;
        }
        const users = message.names;
        if (!users) {
            this.services.logger.error(constants_1.PARSER_ACTION[constants_1.PARSER_ACTION.INVALID_MESSAGE], `invalid presence names parameter ${constants_1.PRESENCE_ACTION[message.action]}`);
            return;
        }
        if (message.action === constants_1.PRESENCE_ACTION.SUBSCRIBE) {
            this.subscriptionRegistry.subscribeBulk(message, socketWrapper);
            return;
        }
        if (message.action === constants_1.PRESENCE_ACTION.UNSUBSCRIBE) {
            this.subscriptionRegistry.unsubscribeBulk(message, socketWrapper);
            return;
        }
        if (message.action === constants_1.PRESENCE_ACTION.QUERY) {
            this.handleQuery(users, message.correlationId, socketWrapper);
            return;
        }
        this.services.logger.warn(constants_1.PARSER_ACTION[constants_1.PARSER_ACTION.UNKNOWN_ACTION], constants_1.PRESENCE_ACTION[message.action], this.metaData);
    }
    /**
    * Called whenever a client has succesfully logged in with a username
    */
    onClientConnected(socketWrapper) {
        if (socketWrapper.userId === 'OPEN') {
            return;
        }
        const currentCount = this.localClients.get(socketWrapper.userId);
        if (currentCount === undefined) {
            this.localClients.set(socketWrapper.userId, 1);
            this.connectedClients.add(socketWrapper.userId);
        }
        else {
            this.localClients.set(socketWrapper.userId, currentCount + 1);
        }
    }
    /**
    * Called whenever a client has disconnected
    */
    onClientDisconnected(socketWrapper) {
        if (socketWrapper.userId === 'OPEN') {
            return;
        }
        const currentCount = this.localClients.get(socketWrapper.userId);
        if (!currentCount) {
            // TODO: Log Error
        }
        else if (currentCount === 1) {
            this.localClients.delete(socketWrapper.userId);
            this.connectedClients.remove(socketWrapper.userId);
        }
        else {
            this.localClients.set(socketWrapper.userId, currentCount - 1);
        }
    }
    handleQueryAll(correlationId, socketWrapper) {
        const clients = this.connectedClients.getAll();
        const index = clients.indexOf(socketWrapper.userId);
        if (index !== -1) {
            clients.splice(index, 1);
        }
        socketWrapper.sendMessage({
            topic: constants_1.TOPIC.PRESENCE,
            action: constants_1.PRESENCE_ACTION.QUERY_ALL_RESPONSE,
            names: clients
        });
    }
    /**
    * Handles finding clients who are connected and splicing out the client
    * querying for users
    */
    handleQuery(users, correlationId, socketWrapper) {
        const result = {};
        const clients = this.connectedClients.getAll();
        for (let i = 0; i < users.length; i++) {
            result[users[i]] = clients.includes(users[i]);
        }
        socketWrapper.sendMessage({
            topic: constants_1.TOPIC.PRESENCE,
            action: constants_1.PRESENCE_ACTION.QUERY_RESPONSE,
            correlationId,
            parsedData: result,
        });
    }
    /**
    * Alerts all clients who are subscribed to
    * PRESENCE_JOIN that a new client has been added.
    */
    onClientAdded(username) {
        const individualMessage = {
            topic: constants_1.TOPIC.PRESENCE,
            action: constants_1.PRESENCE_ACTION.PRESENCE_JOIN,
            name: username,
        };
        const allMessage = {
            topic: constants_1.TOPIC.PRESENCE,
            action: constants_1.PRESENCE_ACTION.PRESENCE_JOIN_ALL,
            name: username
        };
        this.subscriptionRegistry.sendToSubscribers(EVERYONE, allMessage, false, null, true);
        this.subscriptionRegistry.sendToSubscribers(username, individualMessage, false, null, true);
    }
    /**
    * Alerts all clients who are subscribed to
    * PRESENCE_LEAVE that the client has left.
    */
    onClientRemoved(username) {
        const individualMessage = {
            topic: constants_1.TOPIC.PRESENCE,
            action: constants_1.PRESENCE_ACTION.PRESENCE_LEAVE,
            name: username,
        };
        const allMessage = {
            topic: constants_1.TOPIC.PRESENCE,
            action: constants_1.PRESENCE_ACTION.PRESENCE_LEAVE_ALL,
            name: username
        };
        this.subscriptionRegistry.sendToSubscribers(EVERYONE, allMessage, false, null);
        this.subscriptionRegistry.sendToSubscribers(username, individualMessage, false, null);
    }
}
exports.default = PresenceHandler;
//# sourceMappingURL=presence-handler.js.map